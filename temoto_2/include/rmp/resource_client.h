#ifndef RESOURCE_CLIENT_H
#define RESOURCE_CLIENT_H
#include "ros/ros.h"
#include "common/temoto_id.h"
#include "rmp/base_resource_client.h"
#include "rmp/client_query.h"
#include "rmp/log_macros.h"
#include <string>
#include <map>

namespace rmp
{
// template <class Owner>
// class ResourceManager;

template <class ServiceType, class Owner>
class ResourceClient : public BaseResourceClient<Owner>
{
public:
  ResourceClient(std::string ext_temoto_namespace, std::string ext_resource_manager_name,
                 std::string ext_server_name, Owner* owner,
                 ResourceManager<Owner>& resource_manager)
    : BaseResourceClient<Owner>(resource_manager)
    , ext_resource_manager_name_(ext_resource_manager_name)
    , ext_server_name_(ext_server_name)
    , ext_temoto_namespace_(ext_temoto_namespace)
    , owner_(owner)
  {
    log_class_ = "rmp/Client";
    log_subsys_ = owner_->getName();
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    // Set client name where it is connecting to.
    name_ = '/' + ext_temoto_namespace + '/' + ext_resource_manager_name + "/" + ext_server_name;
    //std::string load_srv_name = srv_name::PREFIX + "/" + name_;
    //std::string unload_name = srv_name::PREFIX + "/" + ext_resource_manager_name + "/unload";
    std::string load_srv_name = name_;
    std::string unload_name = '/' + ext_temoto_namespace + '/' + ext_resource_manager_name + "/unload";

    // Setup ROS service clients for loading and unloading the resource
    service_client_ = nh_.serviceClient<ServiceType>(load_srv_name);
    service_client_unload_ = nh_.serviceClient<temoto_2::UnloadResource>(unload_name);
    RMP_DEBUG("%s Created ResourceClient %s", prefix.c_str(), name_.c_str());
  }

  ~ResourceClient()
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    RMP_DEBUG("%s Destroyed ResourceClient %s", prefix.c_str(), name_.c_str());
  }

  bool call(ServiceType& msg)
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    //RMP_DEBUG("%s", prefix.c_str());

    // store the internal id that is generated by resource manager
    // same internal id is used for server and client, when client was
    // called due to server callback
    temoto_id::ID internal_resource_id = msg.response.rmp.resource_id;

    // search for given service request from previous queries
    auto q_it = std::find_if(queries_.begin(), queries_.end(),
                             [&](const ClientQuery<ServiceType, Owner>& q) -> bool {
                               return q.getMsg().request == msg.request && !q.failed_;
                             });
    if (q_it == queries_.end())
    {
      // New request
      // Prepare return topic
      //std::string topic = srv_name::PREFIX + "/" + this->resource_manager_.getName() + "/status";
      std::string topic = '/' + ext_temoto_namespace_ + '/' + this->resource_manager_.getName() + "/status";
      msg.request.rmp.status_topic = topic;
      RMP_DEBUG("%s New query, performing external call to %s", prefix.c_str(),
               service_client_.getService().c_str());
      if (service_client_.call(msg))
      {
        RMP_DEBUG("%s Service call was sucessful. ext id: %ld", prefix.c_str(),
                 msg.response.rmp.resource_id);
        queries_.emplace_back(msg, owner_);
        q_it = std::prev(queries_.end());  // set iterator to the added query
      }
      else
      {
        RMP_ERROR("%s Service call to %s returned false.", prefix.c_str(), service_client_.getService().c_str());
        return false;  // something went wrong, return immediately
      }
    }
    else
    {
      // Equal request was found from stored list
      RMP_DEBUG("%s Existing request, using stored response", prefix.c_str());

      // Fill the response part with the one that was found from queries_
      msg.response = q_it->getMsg().response;
    }

    // Determine the caller's name, which is server name when the
    // call came from some server callback, or an empty string when it did not.

    std::string server_name = this->resource_manager_.getActiveServerName();
    q_it->addInternalResource(internal_resource_id, server_name);

    // Update id in response part
    msg.response.rmp.resource_id = internal_resource_id;

    return true;
  }

  void removeResource(temoto_id::ID resource_id)
  {
    // search for given resource id to unload
    auto q_it = std::find_if(queries_.begin(), queries_.end(),
                             [&](const ClientQuery<ServiceType, Owner>& q) -> bool {
                               return q.internalResourceExists(resource_id);
                             });
    if (q_it != queries_.end())
    {
      size_t caller_cnt = q_it->removeInternalResource(resource_id);
      if (caller_cnt <= 0)
      {
        queries_.erase(q_it);
      }
    }
  }

  /// Remove all queries and send unload requests to external servers
  void unloadResources()
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    RMP_DEBUG("%s ResourceClient %s is unloading %lu queries.", prefix.c_str(), name_.c_str(), queries_.size());
    for (auto& q : queries_)
    {
      sendUnloadRequest(q.getExternalId());
    }
    queries_.clear();
  }

  // unload by internal resource_id
  void unloadResource(temoto_id::ID resource_id)
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    RMP_DEBUG("%s Unloading resource with id:%d", prefix.c_str(), resource_id);
    // search for given resource id to unload
    auto q_it = std::find_if(queries_.begin(), queries_.end(),
                             [&](const ClientQuery<ServiceType, Owner>& q) -> bool {
                               return q.internalResourceExists(resource_id);
                             });
    if (q_it != queries_.end())
    {
      size_t connections_remaining = q_it->removeInternalResource(resource_id);
      if (connections_remaining <= 0)
      {
        sendUnloadRequest(q_it->getExternalId());
        queries_.erase(q_it);
      }
    }
  }

  //TODO: REMOVE THIS STUFF
  void setFailedFlag(temoto_id::ID external_resource_id)
  {
    auto q_it = std::find_if(queries_.begin(), queries_.end(),
                             [&](const ClientQuery<ServiceType, Owner>& q) -> bool {
                               return q.getExternalId() == external_resource_id;
                             });
    if (q_it != queries_.end())
    {
      q_it->failed_ = true;
    }
  }

  /// Send unload service request to the server
  void sendUnloadRequest(temoto_id::ID ext_resource_id)
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    temoto_2::UnloadResource unload_msg;
    unload_msg.request.server_name = ext_server_name_;
    unload_msg.request.resource_id = ext_resource_id;
    RMP_DEBUG("%s Sending unload to %s", prefix.c_str(),
             service_client_unload_.getService().c_str());
    if (!service_client_unload_.call(unload_msg))
    {
      RMP_ERROR("%s Call to %s failed.", prefix.c_str(),
                service_client_unload_.getService().c_str());
    }
  }

  /// Returns internal resources of all queries in this client.
  std::map<temoto_id::ID, std::string> getInternalResources() const
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    std::map<temoto_id::ID, std::string> ret;
    for (auto& q : queries_)
    {
      std::map<temoto_id::ID, std::string> r = q.getInternalResources();
      ret.insert(r.begin(), r.end());
    }
    return ret;
  }

  /// Search for the query that matches given external resource_id,
  // and return all internal connections that this query has.
  const std::map<temoto_id::ID, std::string>
  getInternalResources(temoto_id::ID ext_resource_id) const
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    std::map<temoto_id::ID, std::string> internal_resources;
    const auto q_it = std::find_if(queries_.begin(), queries_.end(),
                                   [&](const ClientQuery<ServiceType, Owner>& q) -> bool {
                                     return q.getMsg().response.rmp.resource_id == ext_resource_id;
                                   });
    if (q_it != queries_.end())
    {
      internal_resources = q_it->getInternalResources();
    }
    else
    {
      RMP_ERROR("%s No query with given resource_id was not found!", prefix.c_str());
    }

    return internal_resources;
  }

  bool internalResourceExists(temoto_id::ID resource_id)
  {
    auto q_it = std::find_if(queries_.begin(), queries_.end(),
                             [&](const ClientQuery<ServiceType, Owner>& q) -> bool {
                               return q.internalResourceExists(resource_id);
                             });
    return q_it != queries_.end();
  }

  size_t getQueryCount() const
  {
    return queries_.size();
  }

  const std::string& getName() const
  {
    return name_;
  }

  const std::string& getExtServerName() const
  {
    return ext_server_name_;
  }

  void debug()
  {
    std::string prefix = common::generateLogPrefix(log_subsys_, log_class_, "");
    RMP_DEBUG("%s  Client name: %s", prefix.c_str(), name_.c_str());
    RMP_DEBUG("%s  Ext server name: %s",prefix.c_str(), ext_server_name_.c_str());
    RMP_DEBUG("%s  Ext RM name: %s",prefix.c_str(), ext_resource_manager_name_.c_str());
    for(auto& q : queries_)
    {
      q.debug();
    }
  }

private:
  std::string log_class_, log_subsys_;
  std::string name_;                       ///< The unique name of a resource client.
  std::string ext_server_name_;            ///< The name of the server client calls.
  std::string ext_resource_manager_name_;  ///< Name of resource manager where the server is located at
  std::string ext_temoto_namespace_;       ///< Name of the destination temoto namespace.
  std::vector<ClientQuery<ServiceType, Owner>> queries_;

  Owner* owner_;

  ros::ServiceClient service_client_;
  ros::ServiceClient service_client_unload_;
  ros::NodeHandle nh_;
};
}

#endif
